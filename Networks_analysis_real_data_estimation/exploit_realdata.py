import pandas as pd
import os 
import pickle
import numpy as np
import matplotlib.pyplot as plt
from src import mcmc
from scipy.stats import mannwhitneyu
import plotly.express as px

d=25
save=False

#Load data
path_data="TOFILL"
netmat = np.loadtxt(os.path.join(path_data,"netmats2_d"+str(d)+".txt"), comments="#", delimiter=" ", unpack=False)

#load parameter estimation and restults
path_save="Networks_analysis_real_data_estimation/result"
path_save_param="Networks_analysis_real_data_estimation/param"
n,p=(d,5)
#(F, mu, sigma, sigma_l)

netmat_mat=np.reshape(netmat,(812,d,-1))
from sklearn.decomposition import PCA

#PCA on the fata, netmat is an array of size (812,25x25), there are 812 networks
pca = PCA(n_components=p)
pca.fit(netmat)
netmat_coef=pca.transform(netmat)
components_=pca.components_
mat_reconstruction=netmat_coef@components_
norm_pca_recon=np.linalg.norm(netmat-mat_reconstruction,axis=1)
#reconstruction error, RMSE adn rRMSE
print("pca")
print("mean rmse",np.mean(norm_pca_recon),"std",np.std(norm_pca_recon))
print("mean rel-rmse",np.mean(norm_pca_recon/np.linalg.norm(netmat,axis=1)),"std",np.std(norm_pca_recon/np.linalg.norm(netmat,axis=1)))

k=0

#Fonction to compute the score of reconstruction
def score(Z):
    print("mean rmse",np.mean(Z),"std",np.min(Z),np.max(Z))
    print("mean rel-rmse",np.mean(Z/np.linalg.norm(netmat,axis=1)),"min,max",np.min(Z/np.linalg.norm(netmat,axis=1)),np.max(Z/np.linalg.norm(netmat,axis=1)))

def recon_rmse(netmat_mat, theta,Xs,ls):
    """
    Perform posterior sampling on Xs,ls knwowing the observations netmat_mat and the parameter theta,
    in order to reconstruct the observations 
    """
    Xl_history,_, _, _, _, _=mcmc.slice_rieman(netmat_mat, theta, n_iter=1000, init=(Xs,ls), prop_X=1, prop_l=0.1, setting="gaussian",m=10)# posteterior sampling
    Z=np.zeros(len(Xs))
    for i in range(len(Xs)):
        A=np.zeros((len(Xs[0]),len(Xs[0])))
        for j in range(400,len(Xl_history),10): #we take one sample out of 10
            X,lamb=Xl_history[j]
            A=A+(X[i]*lamb[i])@X[i].T
        A=10*A/(len(Xl_history)-400)#posterior average reconstriuction
        Z[i]=np.linalg.norm(A-netmat_mat[i])
        
    return Z

def recon_rmse_trivial(Xs,ls):
    # reconstruction without posterior sampling, directly from Xs,ls return at the end of the estimation
    
    for i in range(len(Xs)):
        
        A=(Xs[i]*ls[i])@Xs[i].T
        Z[i]=np.linalg.norm(A-netmat_mat[i])
        
    return Z

for slice in [True, False]:
    #Open parameters
    if slice:
        print("GSS")
        lks=pd.read_csv(os.path.join(path_save,"slice_estimation_real_lks_n_p{:.0f},{:.0f}".format(n,p))).values
        with open(os.path.join(path_save_param,"slice_estimation_real_param_n_p{:.0f},{:.0f}".format(n,p)), 'rb') as f:
            theta=pickle.load(f)

        with open(os.path.join(path_save_param,"slice_estimation_real_Xs_n_p{:.0f},{:.0f}".format(n,p)), 'rb') as f:
            Xs=pickle.load(f)
        with open(os.path.join(path_save_param,"slice_estimation_real_ls_n_p{:.0f},{:.0f}".format(n,p)), 'rb') as f:
            ls=pickle.load(f)
    else:
        print("mh adapt")
        lks=pd.read_csv(os.path.join(path_save,"mhadapt_estimation_real_lks_n_p{:.0f},{:.0f}".format(n,p))).values
        with open(os.path.join(path_save_param,"mhadapt_estimation_real_param_n_p{:.0f},{:.0f}".format(n,p)), 'rb') as f:
            theta=pickle.load(f)
        with open(os.path.join(path_save_param,"mhadapt_estimation_real_Xs_n_p{:.0f},{:.0f}".format(n,p)), 'rb') as f:
            Xs=pickle.load(f)
        with open(os.path.join(path_save_param,"mhadapt_estimation_real_ls_n_p{:.0f},{:.0f}".format(n,p)), 'rb') as f:
            ls=pickle.load(f)
    
    
    if slice:
        plt.figure(0)
        #plot of the log complete likelihood for GSS
        plt.title('log complete likelihood evolution')
        plt.plot(lks[:,1],"-",label="GSS",linewidth=4,color="blue")
        if save:
            #if we compute the reconstruction by sampling the posterior for the first time
            Z=recon_rmse(netmat_mat, theta,Xs,ls)
            with open(os.path.join(path_save_param,"slice_Z_dist_n_p{:.0f},{:.0f}".format(n,p)), 'wb') as f:
                pickle.dump(Z,f)
        else:
            with open(os.path.join(path_save_param,"slice_Z_dist_n_p{:.0f},{:.0f}".format(n,p)), 'rb') as f:
                Z=pickle.load(f)
        Z_slice=Z.copy()
    else:
        plt.figure(0)
        #plot of the log complete likelihood for RMH
        plt.plot(lks[:,1],"--",label="RMH",linewidth=4,color="red")
        if save:
            #if we compute the reconstruction by sampling the posterior for the first time
            Z=recon_rmse(netmat_mat, theta,Xs,ls)
            with open(os.path.join(path_save_param,"mh_Z_dist_n_p{:.0f},{:.0f}".format(n,p)), 'wb') as f:
                pickle.dump(Z,f)
        else:# If the reconstruction was already computed
            with open(os.path.join(path_save_param,"mh_Z_dist_n_p{:.0f},{:.0f}".format(n,p)), 'rb') as f:
                Z=pickle.load(f)
        Z_mh=Z.copy()

    score(Z)
    
    print("trivial")
    score(recon_rmse_trivial(Xs,ls))
    
    
    print("sigma,sigmal",theta[2],theta[3])
    F,mu=theta[0],theta[1]
    
    F_n=F/np.linalg.norm(F,axis=0)
    if slice:
        name="GSS: "
        base_slice=(F_n*mu)@F_n.T
    else:
        name="RMH: "
        base_mh=(F_n*mu)@F_n.T

    
    # print the different learned components
    # for i in range(p):
    #     print(i,"component")
    #     print("norm F",np.linalg.norm(F[:,i]))
    #     print("norm mu",abs(mu[i]))
    #     F_s=np.reshape(F[:,i],(-1,1))
    #     mat=F_s@F_s.T/np.linalg.norm(F[:,i])**2
    #     print(mat.shape)
    #     sign_mu=mu[i]/abs(mu[i])
    #     mat_mu=mat*sign_mu
    #     plt.figure(100+k*10+2+i)
    #     plt.title(name+"mat of the "+str(i)+" component")
    #     plt.imshow(mat_mu)
    #     plt.colorbar()
    k=k+1
Z_pca_rrmse=norm_pca_recon/np.linalg.norm(netmat,axis=1)
Z_mh_rrmse=Z_mh/np.linalg.norm(netmat,axis=1)
Z_slice_rrmse=Z_slice/np.linalg.norm(netmat,axis=1)
Z_concat=np.concatenate([Z_mh_rrmse[:,None],Z_slice_rrmse[:,None],Z_pca_rrmse[:,None]],axis=1)

#print the box blots of rRMSE
fig=px.box(Z_concat,title='boxplots, RMH=0 GSS=1 pca=2')

fig.show()



# comparaison to the mean, not very infirmative
# print(np.linalg.norm(base_mh-base_slice))
# print("dist mean mh")
# print(np.linalg.norm(base_mh-netmat_mat.mean(axis=0))/np.linalg.norm(netmat_mat.mean(axis=0)))
# print("dist mean slice")
# print(np.linalg.norm(base_slice-netmat_mat.mean(axis=0))/np.linalg.norm(netmat_mat.mean(axis=0)))

# plt.figure(300)
# plt.title("GSS mean")
# plt.imshow(base_slice)
# plt.colorbar()
# plt.figure(301)
# plt.title("RMH mean")
# plt.imshow(base_mh)
# plt.colorbar()
# plt.figure(302)
# plt.title(" mean data")
# plt.imshow(netmat_mat.mean(axis=0))
# plt.colorbar()


plt.legend()
plt.show()
plt.ion()